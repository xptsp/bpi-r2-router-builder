#############################################################################
# Define rules that affect both IPv4 and IPv6:
#############################################################################
add table inet firewall { }
flush table inet firewall
table inet firewall {

################################################[ MAPS & SETS ]#################################################
	# List of WAN interfaces:
	set DEV_WAN { type ifname; elements = { wan } }

	# List of interfaces denied access to WAN interfaces:
	set DEV_WAN_DENY { type ifname; }

	# List of LAN interfaces:
	set DEV_LAN { type ifname; elements = { br0, mt7615_24g, mt7615_5g } }

	# List of interfaces denied access to WAN interfaces from LAN:
	set DEV_LAN_DENY { type ifname; }

	############################[ Captive Portal Info ]#############################
	# List of interfaces that have a Captive Portal on them:
	set DEV_PORTAL { type ifname; }

	# List of MAC addresses that passed Captive Portal:
	set PORTAL_PASS { type ether_addr; }

	##########################[ Accept TCP/UDP Port Sets ]##########################
	set ACCEPT_PORT_TCP { type inet_service; flags interval; }
	set ACCEPT_PORT_UDP { type inet_service; flags interval; }

	############################[ Port Triggering Sets ]############################
	set TRIGGER_LIST_TCP { type inet_service; flags interval; }
	set TRIGGER_LIST_UDP { type inet_service; flags interval; }

	###########################[ Port Forwarding Stuff ]############################
	map FORWARD_PORT_TCP { type inet_service : ipv4_addr . inet_service; }
	map FORWARD_PORT_UDP { type inet_service : ipv4_addr . inet_service; }
	map FORWARD_RANGE_TCP { type inet_service : ipv4_addr; flags interval; }
	map FORWARD_RANGE_UDP { type inet_service : ipv4_addr; flags interval; }

############################################[ DO NOT EDIT THESE ]#############################################
	set PRIVATE_SUBNETS { 
		type ipv4_addr; flags interval;
		elements = { 0.0.0.0/8, 10.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.0.2.0/24, 192.168.0.0/16, 224.0.0.0/5, 240.0.0.0/5 } 
	}
	set INSIDE_NETWORK { type ipv4_addr; flags interval; elements = { 192.168.2.0/24, 192.168.21.0/24, 192.168.22.0/24 } }
	set TRIGGER_OPEN_TCP { type inet_service; flags timeout; }
	map TRIGGER_PORT_TCP { type inet_service : ipv4_addr; }
	set TRIGGER_OPEN_UDP { type inet_service; flags timeout; }
	map TRIGGER_PORT_UDP { type inet_service : ipv4_addr; }

##############################################[ Filter: INPUT ]###############################################
	chain input {
		type filter hook input priority filter; policy drop;

		# Attempt to mitigate TCP RST floods:
		tcp flags & (rst) == rst limit rate 2/second burst 2 packets counter accept comment "TCP RST Flood"
		tcp flags & (rst) == rst counter drop comment "TCP RST Flood"

		# Allow traffic from established and related packets, drop invalid
		ct state vmap { established : accept, related : accept, invalid : drop }

		# Redirect incoming port 67 to port 68:
		meta l4proto udp udp sport 67 udp dport 68 accept

		# Accept neighbour discovery, otherwise connectivity breaks:
		icmpv6 type { nd-neighbor-solicit, nd-router-advert, nd-neighbor-advert } accept

		# Accept anything that has been DNAT'ed:
		ct status dnat accept

		# Accept all connections from "lo" interface:
		iifname lo accept

		# Jump to "input_wan" chain for our WAN interfaces:
		iifname @DEV_WAN jump input_wan

		# Drop any remaining packets from our WAN interfaces:
		iifname @DEV_WAN drop

		# Jump to "input_lan" chain for our LAN interfaces:
		iifname @DEV_LAN jump input_lan

		# Allow traffic from loopback and LAN interfaces:
		iifname @DEV_LAN accept
	}

	#############################################################################
	chain input_wan {
		# Accept any ports listed in "ACCEPT_PORT_TCP" and "ACCEPT_PORT_UDP" sets:
		tcp dport @ACCEPT_PORT_TCP accept
		udp dport @ACCEPT_PORT_UDP accept
	}

	#############################################################################
	chain input_lan {
	}

#############################################[ Filter: FORWARD ]##############################################
	chain forward {
		type filter hook forward priority filter; policy drop;

		# Allow traffic from established and related packets, drop invalid:
		ct state vmap { established : accept, related : accept, invalid : drop }

		# Accept anything that has been DNAT'ed:
		ct status dnat accept

		# All portal interfaces must jump to "forward_portal" chain now:
		iifname @DEV_PORTAL jump forward_portal

		# LAN to WAN communication must jump to "forward_wan" chain now:
		iifname @DEV_LAN oifname @DEV_WAN jump forward_wan

		# Reject communication from WAN-restricted interfaces to WAN interfaces:
		iifname @DEV_WAN_DENY oifname @DEV_WAN reject

		# Forward connections from the LAN interfaces to WAN interfaces:
		iifname @DEV_LAN oifname @DEV_WAN accept

		# LAN to LAN communication must jump to "forward_lan" chain now:
		iifname @DEV_LAN oifname @DEV_LAN jump forward_lan

		# Reject communication from LAN-restricted interfaces to LAN interfaces:
		iifname @DEV_LAN_DENY oifname @DEV_LAN reject

		# Forward connections from the LAN interfaces to LAN interfaces:
		iifname @DEV_LAN oifname @DEV_LAN accept
	}

	#############################################################################
	chain forward_portal {
		# Return processing any packet that has the "Pass" mark back to calling chain:
		# NOTE: "0x50617373" is "Pass" converted to hexadecimal! :p  ==> CMD: "printf Pass | xxd -p" <==
		mark 0x50617373 return

		# Accept any packets directed to the Captive Portal WebUI:
		ip daddr 192.168.2.1 tcp dport 80 accept

		# Accept all DNS and DHCP communication:
		meta l4proto {tcp, udp} @th,16,16 { 53, 67 } accept

		# Reject all other communication:
		reject
	}

	#############################################################################
	chain forward_wan {
	}

	#############################################################################
	chain forward_lan {
	}

##############################################[ Filter: OUTPUT ]##############################################
	chain output {
		type filter hook output priority filter; policy accept;

		# User "vpn" must jump to the "output_vpn" chain now:
		meta skuid "vpn" jump output_vpn

		# All WAN interfaces must jump to the "output_wan" chain now:
		oifname @DEV_WAN jump output_wan

		# All LAN interfaces must jump to the "output_lan" chain now:
		oifname @DEV_LAN jump output_lan
	}

	#############################################################################
	chain output_vpn {
		# Default rule is to block from accessing anything but the "lo" interface.
		# This rule will be replaced by the OpenVPN configuration script when connecting.
		oifname != "lo" drop
	}

	#############################################################################
	chain output_wan {
	}

	#############################################################################
	chain output_lan {
	}

##############################################[ Mangle: OUTPUT ]##############################################
	chain mangle_output {
		type route hook output priority mangle; policy accept;

		# All packets must jump to "output_vpn" chain now:
		jump mangle_output_vpn
	}

	#############################################################################
	chain mangle_output_vpn {
	}

############################################[ Mangle: PREROUTING ]############################################
	chain mangle_prerouting {
		type filter hook prerouting priority mangle; policy accept;
		
		# Mark any packets from MAC addresses that passed the Captive Portal with "Pass" flag.
		# NOTE: "0x50617373" is "Pass" converted to hexadecimal! :p  ==> CMD: "printf Pass | xxd -p" <==
		iifname @DEV_PORTAL ether saddr @PORTAL_PASS counter meta mark set 0x50617373
	}

	#############################################################################
	chain mangle_prerouting_ddos {
		# Drop packets that use bogus TCP flags:
		tcp flags & (fin|syn) == fin|syn counter drop comment "Bogus TCP flags"
		tcp flags & (syn|rst) == syn|rst counter drop comment "Bogus TCP flags"
		tcp flags & (fin|rst) == fin|rst counter drop comment "Bogus TCP flags"
		tcp flags & (fin|ack) == fin counter drop comment "Bogus TCP flags"
		tcp flags & (ack|urg) == urg counter drop comment "Bogus TCP flags"
		tcp flags & (psh|ack) == psh counter drop comment "Bogus TCP flags"

		# Drop Null packets:
		tcp flags & (fin|syn|rst|psh|ack|urg) == 0x0 counter drop comment "Null TCP flags"

		# Drop new packets that don't use the SYN flag:
		tcp flags & (fin|syn|rst|ack) != syn ct state new counter drop comment "New Packets without SYN flag"

		# Drop XMAS packets:
		tcp flags & (fin|syn|rst|psh|ack|urg) == fin|syn|rst|psh|ack|urg counter drop comment "XMAS Packets"

		# Block fragmented packets:
		ip frag-off & 0x1fff != 0 counter drop comment "Fragmented packets"

		# Block Packets from spoofing as the "lo" interface:
		iifname != "lo" ip saddr 127.0.0.0/8 counter drop comment "Spoofed IP address"

		# Block Packets From Private Subnets from WAN interfaces.  WAN interfaces should insert an
		# "return" on their IP address/range into the "prerouting_private" chain in order to
		# keep double-nat configurations working as expected:
		iifname @DEV_WAN ip saddr @PRIVATE_SUBNETS jump mangle_prerouting_private
	}

	#############################################################################
	chain mangle_prerouting_private {
		# WAN interfaces should insert an "return" on their IP address/range into the
		# "MANGLE_PREROUTING_PRIVATE" chain in order to keep double-nat configurations working as expected:
		counter drop comment "Private IP subnet from WAN"
	}

#############################################[ NAT: PREROUTING ]##############################################
	chain nat_prerouting {
		type nat hook prerouting priority dstnat; policy accept;

		# All Captive Portal interfaces must jump to "prerouting_portal" chain now:
		iifname @DEV_PORTAL jump nat_prerouting_portal

		# WAN interfaces must jump to "prerouting_wan" chain now:
		iifname @DEV_WAN jump nat_prerouting_wan

		# LAN interfaces must jump to "prerouting_lan" chain now:
		iifname @DEV_LAN jump nat_prerouting_lan
	}

	#############################################################################
	chain nat_prerouting_portal {
		# Accept packets directed to the Captive Portal WebUI:
		ip daddr 192.168.2.1 accept

		# Accept any packet that has the "Pass" mark:
		# NOTE: "0x50617373" is "Pass" converted to hexadecimal! :p  ==> CMD: "printf Pass | xxd -p" <==
		mark 0x50617373 accept

		#  Redirect any HTTP requests to the Captive Portal WebUI:
		tcp dport 80 dnat ip to 192.168.2.1
	}

	#############################################################################
	chain nat_prerouting_wan {
		# Remove outbound port from "trigger_port" set if timeout has expired:
		tcp dport != @TRIGGER_OPEN_TCP delete @TRIGGER_PORT_TCP { tcp dport : 0.0.0.0 }
		udp dport != @TRIGGER_OPEN_UDP delete @TRIGGER_PORT_UDP { udp dport : 0.0.0.0 }

		# Forward each port in "forward_port" map to it's respective IP address/port combo:
		dnat ip addr . port to tcp dport map @FORWARD_PORT_TCP
		dnat ip addr . port to udp dport map @FORWARD_PORT_UDP

		# Forward range of ports in "trigger_port" map to their respective IP addresses:
		dnat ip to tcp dport map @FORWARD_RANGE_TCP
		dnat ip to udp dport map @FORWARD_RANGE_UDP

		# Forward each port in "trigger_port" map to it's respective IP address --ONLY-- if the timeout hasn't expired:
		tcp dport @TRIGGER_OPEN_TCP dnat ip to tcp dport map @TRIGGER_PORT_TCP
		udp dport @TRIGGER_OPEN_UDP dnat ip to udp dport map @TRIGGER_PORT_UDP
	}

	#############################################################################
	chain nat_prerouting_lan {
	}

#############################################[ NAT: POSTROUTING ]#############################################
	chain nat_postrouting {
		type nat hook postrouting priority srcnat; policy accept;

		# All LAN interfaces must jump to the "nat_postrouting_lan" chain:
		oifname @DEV_LAN jump nat_postrouting_lan

		# All WAN interfaces must jump to the "nat_postrouting_wan" chain:
		oifname @DEV_WAN jump nat_postrouting_wan
	}

	#############################################################################
	chain nat_postrouting_lan {
	}

	#############################################################################
	chain nat_postrouting_wan {
		# If source IP address is from inside the network AND the destination port is in
		# the port triggering list, jump to the "nat_postrouting_trigger" chain:
		ip saddr @INSIDE_NETWORK tcp dport @TRIGGER_LIST_TCP jump nat_postrouting_trigger
		ip saddr @INSIDE_NETWORK udp dport @TRIGGER_LIST_UDP jump nat_postrouting_trigger

		# Masquerade everything going out on our WAN interfaces:
		masquerade
	}

	#############################################################################
	chain nat_postrouting_trigger {
		# Remove outbound port from "trigger_port" set if timeout has expired:
		tcp dport != @TRIGGER_OPEN_TCP delete @TRIGGER_PORT_TCP { tcp dport : 0.0.0.0 }
		udp dport != @TRIGGER_OPEN_UDP delete @TRIGGER_PORT_UDP { udp dport : 0.0.0.0 }

		# Link the outbound port to the source IP address:
		add @TRIGGER_PORT_TCP { tcp dport : ip saddr }
		add @TRIGGER_PORT_UDP { udp dport : ip saddr }

		# Update the timeout for the protocol/port combination:
		update @TRIGGER_OPEN_TCP { tcp dport timeout 10m }
		update @TRIGGER_OPEN_UDP { udp dport timeout 10m }
	}
}
